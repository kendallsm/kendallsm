{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ecuaciones Diferenciales Ordinarias (ODEs)","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>Consideremos el problema \\begin{align} \\frac{{\\rm d}x}{{\\rm d}t} = \\frac{2x}{t}. \\end{align} Esta ecuaci\u00f3n puede ser integrada directamente separando variables de forma an\u00e1litica.</p> <p>Por otro lado, el siguiente problema \\begin{align} \\frac{{\\rm d}x}{{\\rm d}t} = \\frac{2x}{t} + \\frac{3x^2}{t^3}, \\end{align} ya no es separable y adem\u00e1s de eso, es un problema no lineal (en el sentido de que aparecen potencias no lineales de la variable dependiente). </p> <p>Las ecuaciones diferenciales no lineales rara vez se pueden resolver de forma anal\u00edtica. Dado que dichas ecuaciones diferenciales aparecen en distintos campos en la ciencia, debemos atacar el problema de forma num\u00e9rica.</p> <p>El problema general que consideraremos es una ecuaci\u00f3n diferencial ordinaria sujeta a alguna condici\u00f3n inicial. La forma general est\u00e1 dada por  $$ \\frac{\\text d x}{\\text d t} = f(x, t) \\quad \\text{con} \\quad x(t=0)=x_0. $$</p> <p>Algunos de los m\u00e9todos que veremos son aplicables a otras clases de problemas, por ejemplo * $n$D: $\\quad\\displaystyle \\frac{\\text d x_i}{\\text d t} = f_i(x_1,\\dots{},x_n, t)\\quad \\text{con}\\quad x_i(t=0)=x_{i0}.$ * Ordenes mayores, e.g.: $$ \\frac{\\text d^3 x}{\\text d t^3} =f(x, t)\\quad \\Leftrightarrow \\quad \\frac{\\text d x}{\\text d t} = v,\\ \\frac{\\text d v}{\\text d t} = a,\\ \\frac{\\text d a}{\\text d t}=f. $$ * Conjuntos acoplados de ecuaciones diferenciales</p>"},{"location":"#bibliotecas","title":"Bibliotecas","text":"<p>Antes de discutir algoritmos para resolver ODEs, mencionemos las bibliotecas en <code>Python</code> para resolver sistemas. </p> <ul> <li><code>SciPy</code> contiene dos m\u00e9todos para atacar el problema ubicados dentro del m\u00f3dulo <code>scipy.integrate</code></li> <li><code>odeint</code> es el m\u00e9todo cl\u00e1sico de la biblioteca: a pesar de que es poderoso, posee mucha funcionalidad escondida con la cual es dif\u00edcil controlar el c\u00e1lculo, sin mencionar que es complicado entender la forma en que los errores son estimados</li> <li><code>solve_ivp</code> es el m\u00e9todo preferido, dado que nos da mayor control sobre las operaciones realizadas</li> <li>En general, el flujo de trabajo es utilizar alguno de estos m\u00e9todos siempre y cuando no la estimaci\u00f3n de errores no sea tan importante</li> <li>En muchos casos pr\u00e1cticos, estos m\u00e9todos contienen muchos c\u00e1lculos secundarios que pueden hacer la evaluaci\u00f3n de una ecuaci\u00f3n diferencial muy ineficiente. </li> <li>Si el rendimiento de estos m\u00e9todos no es suficiente, lo mejor es implementar un m\u00e9todo que sepamos que se ajusta bien a nuestro problema</li> </ul>"},{"location":"#metodo-de-euler","title":"M\u00e9todo de Euler","text":"<p>El m\u00e9todo de Euler es muy sencillo, se basa en la expansi\u00f3n de Taylor de la funci\u00f3n $x(t)$. Tenemos $$ \\text{Expansi\u00f3n Taylor} \\Rightarrow x(t+h) = x(t) + h\\frac{dx}{dt} + \\overbrace{ \\frac{h^2}{2} \\frac{d^2x}{dt^2} } ^{\\epsilon} + O(h^3). $$ Esto implica que para avanzar en el tiempo la funci\u00f3n por un paso $h$, el cual suponemos que es lo suficientemente peque\u00f1o, basta con utilizar la ecuaci\u00f3n $$ \\boxed{x(t + h) = x(t) + hf(x,t).} $$ El error asociado con la aproximaci\u00f3n est\u00e1 ligado a la cantidad de veces que hagamos la aproximaci\u00f3n, es decir, al n\u00famero de pasos en el tiempo que utilicemos en nuestra soluci\u00f3n. Lo podemos estimar de la siguiente forma $$ \\sum\\epsilon = \\sum_{k=0}^{N-1}\\frac{h^2}{2}\\left. \\frac{d^2x}{dt^2} \\right|{x_k, t_k} = \\frac{h}{2}\\sum{k=0}^{N-1}h\\left.\\frac{df}{dt}\\right|_{x_k, t_k}\\ \\approx \\frac{h}2\\int_a^b\\frac{df}{dt}d t = \\frac{h}{2}\\left[f_b - f_a\\right]. $$ En la ecuaci\u00f3n anterior asumimos que tomamos $N = (b-a)/h$ pasos temporales para llegar al punto final.</p> <p>Entonces, naturalmente, el error total de aproximaci\u00f3n depende $h$ linealmente multiplicado por el intervalo en el cual realizamos la integraci\u00f3n.</p> <ul> <li>Para algunas aplicaciones, esto es suficiente. Para otras, necesitamos una mejor aproximaci\u00f3n.</li> <li>El algoritmo toma la siguiente forma:</li> <li>Empezar con $t = t_0$, $x = x_0$</li> <li>Discretizar el tiempo en pasos temporales de forma equidistante con espaciamiento $h$, donde cada punto en el tiempo est\u00e1 denotado con $t_i$</li> <li>Para cada punto en el tiempo encontrar $x$ utilizando el resultado de la iteraci\u00f3n previa: $x_i = x_{i-1} + hf(x_{i-1})$</li> </ul>"},{"location":"#metodo-de-runge-kutta","title":"M\u00e9todo de Runge-Kutta","text":"<p>El m\u00e9todo de Euler puede darnos una buena aproximaci\u00f3n dependiendo del problema y de la cantidad de iteraciones que necesitamos en nuestra soluci\u00f3n. En general, con el m\u00e9todo de Euler, un c\u00e1lculo que es el doble m\u00e1s preciso requiere el doble de recursos computacionales.</p> <p>El m\u00e9todo de Runge-Kutta es en realidad una familia de m\u00e9todos de distinto orden que proveen una mejor aproximaci\u00f3n sin la necesidad de considerar ordenes m\u00e1s altos en la expansi\u00f3n de Taylor del m\u00e9todo de Euler. Este \u00faltimo punto se quiere evitar, dado que es complicado conocer la derivada de la funci\u00f3n que estamos evaluando en el lado derecho de la ODE.</p>"},{"location":"#metodo-de-runge-kutta-2rm-do-orden-rk2","title":"M\u00e9todo de Runge-Kutta 2$^{\\rm do}$ Orden (RK2)","text":"<p>La idea del m\u00e9todo RK2 es utilizar el punto medio para evaluar el m\u00e9todo de Euler, como se indica en la figura. Mientras que el m\u00e9todo de Euler se aplica en el punto $t$ para evaluar la derivada para aproximar la funci\u00f3n en el punto $x = t + h$, el m\u00e9todo RK2 utiliza el punto medio $t + h/2$. </p> <p>De esta forma, se alcanza una mejor aproximaci\u00f3n para el mismo valor de $h$.</p> <p>El m\u00e9todo se deriva aplicando la serie de Taylor alrededor del punto medio $t + h/2$ para obtener el valor de la funci\u00f3n en el punto $x(t + h)$. Tenemos $$ x(t + h) = x\\left(t + \\frac{h}{2}\\right) + \\frac{h}{2}\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right){t+h/2} + \\frac{h^2}{8}\\left(\\frac{{\\rm d}^2x}{{\\rm d}t^2}\\right){t+h/2} + O(h^3). $$ Similarmente, podemos hacer lo mismo para $x(t)$, tal que $$ x(t) = x\\left(t + \\frac{h}{2}\\right) - \\frac{h}{2}\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right){t+h/2} + \\frac{h^2}{8}\\left(\\frac{{\\rm d}^2x}{{\\rm d}t^2}\\right){t+h/2} + O(h^3). $$ Al sustraer ambas ecuaciones obtenemos $$ x(t + h) = x(t) + h\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right)_{t+h/2} + O(h^3) $$ Finalmente, $$ \\boxed{x(t + h) = x(t) + hf[x(t + h/2), t + h/2] + O(h^3)}. $$ El t\u00e9rmino de orden $h^2$ desaparece y nuestra aproximaci\u00f3n tiene un error de orden $h^3$. Recordemos que incrementar el orden del error por un orden de magnitud es muy beneficioso a nivel computacional. </p> <p>El \u00fanico problema es que requerimos conocer el valor de la funci\u00f3n en el punto medio $x(t + h/2)$, el cual desconocemos.</p> <p>Para aproximar este valor utilizamos el m\u00e9todo de Euler con un paso $h/2$, $(x + h/2) = x(t) + \\frac{h}{2}f(x,t)$. De esta manera, obtenemos las ecuaciones del m\u00e9todo RK2: * $k_1 = hf(x,t),$ * $k_2 = hf\\left(x + \\frac{k_1}{2},t + \\frac{h}{2}\\right)$ * $x(t + h) = x(t) + k_2$ El error de aproximaci\u00f3n de cada paso es de orden $O(h^3)$, mientras que el error global (con un an\u00e1lisis similar al que hicimos con el m\u00e9todo de Euler) es de order $O(h^2)$. </p> <p>Cabe recalcar que al utilizar el m\u00e9todo de Euler para la primera parte de la aproximaci\u00f3n, el error tambi\u00e9n es de $O(h^3)$ y por ende el error de aproximaci\u00f3n se mantiene de $O(h^3)$.</p>"},{"location":"#metodo-de-runge-kutta-de-4rm-to-orden","title":"M\u00e9todo de Runge-Kutta de 4$^{\\rm to}$ Orden","text":"<p>La metodolog\u00eda anterior se puede aplicar a\u00fan a m\u00e1s puntos ubicados entre $x(t)$ y $x(t + h)$ realizando expansiones de Taylor. De esta forma se pueden agrupar t\u00e9rminos de orden $h^3$, $h^4$, etc; para cancelar dichas expresiones. </p> <p>El problema de hacer esto es que las expresiones se vuelven m\u00e1s complicadas conforme incrementamos el orden de aproximaci\u00f3n. En general, la regla de dedo es que el $4^{\\rm to}$ orden corresponde al mejor compromiso entre complejidad y error de aproximaci\u00f3n. Este m\u00e9todo es el m\u00e1s utilizado comunmente para resolver ODEs. </p> <p>El \u00e1lgebra para encontrar las ecuaciones de $4^{\\rm to}$ orden es tediosa, pero el resultado final es * $k_1 = hf(x, t)$, * $k_2 = hf\\left(x + \\frac{k_1}{2}, t+\\frac{h}2\\right)$, * $k_3 = hf\\left(x + \\frac{k_2}{2}, t+\\frac{h}2\\right)$, * $k_4 = hf\\left(x + k_3, t + h \\right)$, * $x(t+h) = x(t) + \\frac{1}{6}(k_1 + 2 k_2 + 2k_3 + k_4)$.</p> <p>Para la mayor\u00eda de aplicaciones, el m\u00e9todo RK4 es el m\u00e9todo de-facto para obtener soluciones. Es f\u00e1cil de programar y devuelve resultados precisos. </p> <p>El error de aproximaci\u00f3n es $O(h^5)$, mientras que el error global es aproximadamente del orden $O(h^4)$.</p>"},{"location":"#ecuaciones-diferenciales-multivariables","title":"Ecuaciones Diferenciales Multivariables","text":"<p>Podemos tener m\u00e1s de una variable dependiente, e.g., $$ \\frac{\\text d x}{\\text d t} = f_x(x, y, t), \\quad \\frac{\\text d y}{\\text d t} = f(x, y, t), $$ en las cuales $f_x$ y $f_y$ son posiblemente ecuaciones no lineares, lo cual imposibilita en muchos casos el uso de m\u00e9todos anal\u00edticos. </p> <p>Note que estas no son ecuaciones diferenciales parciales, dado que existe solamente una variable independiente.</p> <p>La forma general de estas ecuaciones diferenciales es $$ \\frac{\\text d \\mathbf{r}}{\\text d t} = \\mathbf{f}(\\mathbf{r}, t), $$ con $\\mathbf{r} = (x, y, \\cdots)$ y $\\mathbf{f}(\\mathbf{r}, t) = (f_x(\\mathbf{r}, t), f_y(\\mathbf{r}, t), \\cdots)$. </p> <p>En estos casos los m\u00e9todos de Euler y Runge-Kutta se pueden utilizar directamente sobre los vectores, generalizando las ecuaciones que vimos anteriormente.</p>"},{"location":"#ecuaciones-diferenciales-de-mayor-orden","title":"Ecuaciones Diferenciales de Mayor Orden","text":"<p>La idea es reducir el orden de la ecuaci\u00f3n diferencial a cambio de resolver ecuaciones diferenciales simult\u00e1neas. Por ejemplo, la ecuaci\u00f3n $$ \\frac{\\text d^2 x}{\\text d t^2} = f(x, \\frac{\\text d x}{\\text d t}, t), $$ es equivalente a resolver de forma s imult\u00e1nea * $\\frac{\\text d x}{\\text d t} = y$, * $\\frac{\\text d y}{\\text d t} = f(x, y, t)$.</p> <p>De la misma forma, para ecuaciones de $3^{\\rm er}$ orden, construimos el conjunto de ecuaciones simult\u00e1neas * $\\frac{\\text d x}{\\text d t} = y$, * $\\frac{\\text d y}{\\text d t} = z$, * $\\frac{\\text d z}{\\text d t} = f(x, y, z, t)$.</p> <p>Estas ecuaciones simult\u00e1neas se pueden resolver con el m\u00e9todo deseado (Euler, RK2, RK4) para un sistema multivariable. </p> <p>Este procedimiento se puede realizar para ecuaciones de orden mayor, aunque las ecuaciones diferenciales de orden mayor a 3 en la ciencia son muy poco comunes.</p>"},{"location":"#metodos-adaptativos","title":"M\u00e9todos adaptativos","text":"<p>Existen m\u00e9todos para modificar el paso temporal $h$ de manera tal que los pasos no se toman de forma equidistante. La idea es mantener el error aproximadamente constante a medida que se cambia el paso temporal. </p> <p>Esto puede ser \u00fatil para funciones que cambian muy r\u00e1pido en el tiempo. </p> <p>Ver Newman Cap 8.4 para m\u00e1s detalles. Algunas bibliotecas en <code>Python</code> incluyen metodolog\u00eda para adaptar el algoritmo a pasos $h$ cambiantes. Estas metodolog\u00edas deben ser utilizadas con cuidado dado que incurren en un costo computacional m\u00e1s alto.</p>"},{"location":"#simetria-de-inversion-temporal","title":"Simetr\u00eda de inversi\u00f3n temporal","text":"<p>Muchos problemas en la f\u00edsica involucran una simetr\u00eda importante de invariancia de inversi\u00f3n temporal, la cual puede ser entendida como una consecuencia (o resultado de) la conservaci\u00f3n de la energ\u00eda total.</p> <p>El problema que surge con los m\u00e9todos que hemos derivado es que no respetan esta simetr\u00eda de forma directa, es decir, si empezamos con el valor final y aplicamos el m\u00e9todo en reversa no obtenemos la condici\u00f3n inicial.</p> <p>El ejemplo anterior es la soluci\u00f3n del problema del p\u00e9ndulo no lineal sin fricci\u00f3n, con las ecuaciones $$ \\frac{\\text d \\theta}{\\text d t} = \\omega, \\quad \\frac{\\text d \\omega}{\\text d t} = -\\frac{g}{l}\\sin \\theta. $$ Al aplicar el m\u00e9todo RK2 con cierto valor de $h$, la soluci\u00f3n puede diverger como se muestra en la figura. Existen m\u00e9todos que respetan la simetr\u00eda temporal, los cuales dan el resultado correcto como se muestra. Un ejemplo corresponde al m\u00e9todo de saltos intermedios.</p> <p>Cabe destacar que este problema usualmente se resuelve haciendo el valor de $h$ m\u00e1s peque\u00f1o.</p>"},{"location":"#metodo-de-saltos-intermedios-leapfrog-methods","title":"M\u00e9todo de saltos intermedios (leapfrog methods)","text":"<p>Existe una forma de utilizar los m\u00e9todos anteriores respetando la simetr\u00eda temporal. La forma m\u00e1s b\u00e1sica, es el m\u00e9todo de saltos intermedios.</p> <p>En la figura anterior:    - El diagrama (a) corresponde al caso RK2: utilizamos el punto medio para evaluar la evoluci\u00f3n al paso completo   - El diagrama (b) corresponde al m\u00e9todo de saltos intermedios: utilizamos el punto medio para evaluar la evoluci\u00f3n al paso completo, pero cada punto medio se calcula utilizando el punto medio anterior.</p> <p>Se puede demostrar que este procedimiento respeta la simetr\u00eda de inversi\u00f3n temporal, de manera tal que el error incurrido es de aproximaci\u00f3n y no sistem\u00e1tico, como puede ocurrir con m\u00e9todos directos.</p>"},{"location":"#metodos-avanzados","title":"M\u00e9todos avanzados","text":"<p>Existen m\u00e9todos m\u00e1s avanzados para llevar los saltos intermedios a ordenes mayores.</p> <p>Para m\u00e1s informaci\u00f3n: Newman Cap. 8.</p>"},{"location":"reference/","title":"!/usr/bin/env python3","text":"<p>import numpy as np import matplotlib.pyplot as plt</p> <p>def func(x,t): \"\"\"</p> <pre><code>Diferencial equation to be solved\n\nParameters\n----------\nx : numerical values such as floats or doubles\n    First  argument\nt : numerical values such as floats or doubles\n    Second argument\n\nReturns\n-------\noutput : numerical values such as floats or doubles\n    Returns the value of the diferential equation evaluated at (x,t)\n\nExample\n--------\n--- func(1,np.pi/2)\n0\n\n\n\n\"\"\"\nreturn -x**3 + np.sin(t)\n</code></pre> <p>def euler(f,x_0,t):</p> <p>\"\"\"</p> <pre><code>Euler method used to solve diferential equations\n\nParameters\n-----------\n\nf : numerical values such as floats or doubles\n    First argument\n\nx_0 : numerical values such as floats or doubles\n    Second argument\n\nt : lists\n    Third argument\n\nReturns\n--------\noutput : lists\n    Returns the values of the solved diferential equation at each point\n\nExample\n-------\n\nt = [ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n</code></pre> <p>3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368   6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842   9.47368421 10.        ]</p> <p>--- [ 0.          0.          0.26439534  0.71189381  1.04830651  0.89488942   0.77464602  0.52141013  0.17502349 -0.28921312 -0.80263945 -0.97897518  -0.73458315 -0.50879969 -0.16038526  0.30726691  0.81787725  0.97386719   0.72957635  0.49945695]</p> <p>\"\"\"</p> <pre><code>h = t[1]-t[0]\nx = np.zeros(t.size)\nx[0] = x_0\nfor i in range(1,t.size):\n    x[i] = x[i-1] + h*f(x[i-1],t[i-1])\nreturn x\n</code></pre> <p>def rk2(f,x_0,t):</p> <p>\"\"\"     Runge-Kutta2  method used to solve diferential equations</p> <pre><code>Parameters\n-----------\n\nf : numerical values such as floats or doubles\n    First argument\n\nx_0 : numerical values such as floats or doubles\n    Second argument\n\nt : lists\n    Third argument\n\nReturns\n--------\noutput : lists\n    Returns the values of the solved diferential equation at each point\n\nExample\n-------\n</code></pre> <p>t = [ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895   3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368   6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842   9.47368421 10.        ]</p> <p>---rk2(func,0,t)</p> <p>[ 0.          0.13691106  0.50040599  0.83221858  0.89696773  0.83638552   0.684369    0.42791827  0.0377284  -0.46988042 -0.7896376  -0.78706438  -0.65422559 -0.40234264 -0.0089812   0.49847514  0.79691697  0.78634182   0.64914835  0.39298319]</p> <p>\"\"\"     h = t[1]-t[0]     x = np.zeros(t.size)     x[0] = x_0     for i in range(1,t.size):         k_1 = hf(x[i-1],t[i-1])         k_2 = hf(x[i-1] + 0.5k_1,t[i-1] + h0.5)         x[i] = x[i-1] + k_2     return x</p> <p>def rk4(f,x_0,t):</p> <p>\"\"\"     Runge-Kutta4 method used to solve diferential equations</p> <pre><code>Parameters\n-----------\n\nf : numerical values such as floats or doubles\n    First argument\n\nx_0 : numerical values such as floats or doubles\n    Second argument\n\nt : lists\n    Third argument\n\nReturns\n--------\noutput : lists\n    Returns the values of the solved diferential equation at each point\n\nExample\n-------\n</code></pre> <p>t = [ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895   3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368   6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842   9.47368421 10.        ]</p> <p>---rk4(func,0,t)</p> <p>[ 0.          0.13505937  0.48487586  0.81979626  0.93102462  0.88144889   0.72370945  0.46026479  0.06848691 -0.42773679 -0.78084333 -0.83096351  -0.6993985  -0.43991777 -0.04506765  0.45089026  0.79057875  0.83047637   0.69376603  0.43014634]</p> <p>\"\"\"</p> <pre><code>h = t[1]-t[0]\nx = np.zeros(t.size)\nx[0] = x_0\nfor i in range(1,t.size):\n    k_1 = h*f(x[i-1],t[i-1])\n    k_2 = h*f(x[i-1] + 0.5*k_1,t[i-1] + h*0.5)\n    k_3 = h*f(x[i-1] + 0.5*k_2,t[i-1] + h*0.5)\n    k_4 = h*f(x[i-1] + k_3,t[i-1] + h)\n    x[i] = x[i-1] + (k_1 + 2*k_2 + 2*k_3 + k_4)/6\nreturn x\n</code></pre>"}]}